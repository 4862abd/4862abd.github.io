3장.액션과 계산, 데이터의 차이를 알기

3장 부터는 JS 코드를 이용한 구현 과정이 조금씩 등장한다.
하지만 나는 JS를 이해하고 해석해서 Java의 코드로 구현할 것이며, 이 과정에서 본인에게 불편한게 느껴진다면 편하게 이야기해주면 감사하겠다.
또한 이런 해석 과정을 거치는 것이 처음이므로 포스팅을 거쳐가며 실력을 발전시키겠다.
원본의 JS 코드도 같이 첨부할테니 참고 바란다.

자, 이쯤되면 지긋지긋 하죠?
외워버릴 수 밖에 없겠죠?

액션: 실행 시점과 횟수에 의존한다.
다른 말로 부수 효과(Side-effects), 부수 효과가 있는 함수(Side-effecting function), 순수하지 않은 함수(Impure function) 라고 부르기도 한다.

계산: 입력으로 출력을 계산한다.
다른 말로 순수 함수(Pure function), 수학 함수(Mathematical function) 라고 부르기도 한다.
참조 투명하다.

데이터: 이벤트에 의한 사실


모든 개발 과정에서 액션과 계산, 데이터를 구분하는 기술을 적용하는 것이 좋다고 한다.
예시를 들어보자.

1. 문제에 대해 생각할 때
아직 코딩을 시작하기 전이고 문제에 대해서 고민하고 있을 때도 문제를 액션과 계산, 데이터로 구분할 수 있다.
특히 주의해야할 부분(액션), 데이터, 결정을 내릴 부분(계산) 을 명확하게 알수 있다고 한다.

2. 코딩할 때
드디어 핵심으로 보이는 말이 하나 나왔다.
액션에서 빠르게 계산을 분리해낼 줄 알아야하며, 계산에서는 데이터를 분리해낼 줄 알아야한다.
이는 이전에 봤던 책 중에 "토비의 스프링 3.1" 에도 나온 맥락이다.
크게 따지면 관심사 분리, 조금 더 말하자면 메소드 추출 과도 비슷한 의미로 설명할 것으로 보인다.

3. 코드를 읽을 때
액션과 계산, 데이터를 구분지어 확인할 줄 알아야 하며, 코드를 읽을 때에도 액션을 계산으로, 계산을 데이터로 분리하는
방법을 강구하여 리팩토링하는 방법을 강구해야 할 것이다.


※ 리팩토링?
결과의 변경이 없이 결과를 내기 위한 코드의 구조를 새로 정립하거나 수정하는 작업을 뜻한다.
여러 이유로 리팩토링을 진행하지만, 보통 공부를 했던 책들에서는, "역할과 책임이 뒤섞인 코드에서 각각의 관심사를 분리해낸다." 를
목표로 진행하는 경향이 있더라.
물론 그런 책만 내가 본 것일 수 있다.
실제로 리팩토링은 업무 중에도 자주 진행했다.
코드의 가독성을 위해서 진행하는 경우가 가장 많았고, 코드의 성능을 위해 진행하는 경우도 있었다.
가장 기억에 남는 리팩토링은 MyBatis와 xml을 활용해서 결과를 조회하던 로직을 순수 Java코드를 활용한 JPA로 바꾸면서
같은 결과를 도출하게 하는 작업이었다.
nativeQuery? 사용하지 않았다.
GROUP BY 같이 JPA가 지원하지 않는 기능은 Java의 stream을 활용하는 등, Java로 같은 결과를 낼 수 있게 진행하곤 했다.
물론 산출되는 데이터 자체는 다르겠지만, 그 데이터를 이용해 화면을 송출하는 작업에서는 같은 결과를 내게 하였다.


---

※※ 액션과 계산, 데이터는 어디에나 적용할 수 있습니다.
우리가 일상에서 자주 하는 장보기로 예시를 들었다.

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/d61d405c-0896-4453-9796-c7b48024684b)
냉장고 확인하기 -> 운전해서 상점으로 가기 -> 필요한 것 구입하기 -> 운전해서 집으로 오기
의 과정을 거친다고 하면, 이 모든 단계는 각각의 액션이다.

※ 냉장고 확인하기
냉장고를 확인하는 일은 언제 확인하느냐에 따라 재고가 다르기 때문에 액션이다.
그리고 확인되는 재고는 데이터가 되겠다.

※ 운전해서 상점으로 가기
이건 누가봐도 액션이다.
물론 냉장고를 확인하는 것과 마찬가지로 이벤트에 의한 기록인 데이터가 숨어있긴 하다.
가는 길, 위치, 자동차 종류 등

※ 필요한 것 구입하기
이것도 액션이다.
구입하기 위해 파악한 재고로 필요한 재료를 계산하고, 물건을 골라서 사람들을 피해 줄을 서야할 것이다.

위의 과정을 책에서는 간단하게 이렇게 나열했다.

데이터      현재 재고
데이터      필요한 재고
계산        재고 '빼기'
데이터      장보기 목록에
액션        목록에 있는 것 구입하기

※ 운전해서 집으로 오기
이건 두 번째와 마찬가지라고 생각하면 되겠다.


![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/17d6b45e-7963-4fc6-ba50-0815d2ac23c5)
이런 타임라인 그래프가 완성된다.
필요한 재고는 운전자가 요리를 하기위해 필요한 평소 재고를 기록한 외부의 데이터가 되겠다.
즉, 상수라고 칠 수 있겠다.

이 과정에서 설명하려는 점은 우리는 액션을 최대한 나눌 수 있을 때까지 계산과 데이터로 나누는 것이 중요한 포인트라는 것이다.
그 과정에서 숨어있는 액션이나 계산, 데이터를 발견할 수 있는 것이다.

---

※※ 장보기 과정에서 배운 것
1. 액션과 계산, 데이터는 어디에서 든지 적용될 수 있다.
2. 액션 안에는 계산과 데이터, 또 다른 액션이 숨어 있을 수도 있다.
3. 계산은 더 작은 계산과 데이터로 나누고 연결할 수 있다.
4. 데이터는 데이터만 조합할 수 있다.
5. 계산은 때로 '우리 머리 속에서' 일어날 수 있다.
    ㄴ 우리가 위처럼 유용한 방법에도 실제 코딩할 때 적용하지 않는 가장 큰 이유는, 이미 우리 머리 속에는 그런 과정을 거친다는 것이다.
    ㄴ 어디서 어떤 데이터를 어떻게 구해서 사용할지 머리 속으로 다 계산한다는 것이다.
    ㄴ 우리는 이러한 과정을 나눠서 프로그래밍을 할 줄 알아야 한다.

---
※※※ 데이터에 대해 자세히 알아보기
※ 데이터는 무엇인가?
이벤트에 대한 사실.
일어난 일의 결과를 기록한 것이다.

※ 불변성
함수형 프로그래머는 불변 데이터 구조를 만들기 위해 두 가지 원칙을 사용한다고 한다.
1. 카피-온-라이트(Copy-on-Write)
    ㄴ 변경할 때 복사본을 만든다.
2. 방어적 복사(Defensive copy)
    ㄴ 보관하려고 하는 데이터의 복사본을 만든다.

위의 원칙은 이후 6, 7장에서 다룬다고 한다.

※ 데이터의 장점
데이터는 그 자체로 할 수 있는 것이 없고, 그것이 가장 큰 장점이라고 한다.
"어? 데이터보고 어떤 제품이 더 좋은지 고르거나 구매할 수 있잖아?" 라고 한다면, ※※ 장보기 과정에서 배운 것의 5번을 다시 봐라.
계산은 때로 '우리 머리 속에서' 일어나고 그 데이터는 그 상태 그대로 있을 뿐이었다.
생각이 바뀌고 판단한 것은 우리 머리 속에서 일어난 것이며 계산과 액션을 통해 이뤄진 것이다.

그러면 책에서 설명하는 장점을 살펴보자.
1. 직렬화(Serialization)
직렬화된 액션과 계싼은 다른 곳에서 잘 동작할 것이라는 보장은 없다.
하지만 직렬화된 데이터는 전송하거나 메모리에 저장했다가 읽기 쉬운 장점이 있다.
또한 이 책에서는 JPA에 관해 설명하지 않지만 JPA에서도 직렬화 관련하여 설명하는 부분은 정말 핵심 중 핵심이다.
이는 JPA에 대해 다루는 공부를 할 때, 다시 정리하겠다.

2. 동일성 비교
계산이나 액션은 비교하기 어렵지만 데이터는 비교하기 쉽다.

3. 자유로운 해석
그 자체로는 할 수 있는 일이 전혀 없지만 우리는 데이터를 활용해서 많은 것을 할 수 있다.
어떤 것을 구매할지 고르고, 어떤 것은 믿고 거르는 등 서로 다른 기준을 두고 해석하여 사용하기 쉬운 것이 데이터이다.

※ 데이터의 단점
그 자체로 아무것도 할 수 없다는 것이 단점이다.
모순적이지 않은가?
최근에는 빅데이터다 하면서 날 것 그대로의 데이터를 어떻게 가공하여 활용하는가 가 정말 큰 주제 중 하나였다.
하지만 그건 결국, 데이터는 어떤 방식으로든 해석되어 사용되기를 기다려야 하는 피동적인 존재라는 것이고, 그것이 단점이다.
---


※※ 새로 만드는 코드에 함수형 사고 적용하기
이 과정을 위해 책에서는 사례를 하나 제시한다.
커다란 이메일 데이터베이스가 있으며, 이메일 별로 각 사용자가 추천한 친구 수를 기록하고 있다.
각 사용자에게는 추천한 친구 수로 등급을 나누어 쿠폰을 발급할 것이며 쿠폰은 "bad", "good", "best" 가 존재한다.
그리고 사용자들에게 본인의 등급에 따라 쿠폰을 이메일로 발송할 것이다.
등급을 나누는 기준은 "best"는 10명 이상의 추천, "good"는 best를 제외한 모든 유저, "bad" 쿠폰은 사용하지 않을 것이다.
마지막으로 "bad" 등급의 쿠폰은 사용할 수 없으니 이메일을 전송하지 않을 것이다.


※※ 쿠폰을 보내는 과정을 그려보기
책에서 동작을 설명할 때 사용하는 타임라인 다이어그램을 통해 여기서도 동일하게 진행할 것이다.
우선 DB에서 구독자와 쿠폰 데이터를 가져온다.

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/7b19d162-c407-49b3-9395-b6924105ddf9)
(사진을 구하지 못 해서 직접 촬영했다. 화질구리..)

데이터를 조회해오는 과정은 액션이 되고 조회하는 이벤트에서 기록된 사실은 데이터가 되겠다.

책에서는 중간중간 풀어서 과정을 설명하지만, 자세하게 풀어서 한번에 설명하겠다.

우선 쿠폰과 구독자의 데이터가 있으니 등급을 나눌 필요가 있다.
기준은 추천 수 10 이상이 되겠다.

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/d5264ccd-5ff7-45ac-97a5-8a180fafa07b)
즉, 이러한 과정을 거치게 될 것이다.

이렇게 나눠진 등급을 이용해서 각 이용자에게는 다른 형식의 이메일이 만들어질 것이다.
그 과정을 계산과 데이터로 나누면 이런 형식이 완성된다.

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/647b6924-b5b6-4532-861d-bd908efb9aed)
이메일을 만드는 과정은 액션이 필요하지 않다.
안에 들어가는 내용 자체는 기준이 잡힌 구독자, 쿠폰, 등급 데이터를 이용해서 단순히 작성만 하면 되는 작업이기 때문이다.
하지만 이를 보내는 작업은 액션이 될것이다.

※※ 쿠폰 보내는 과정 구현하기
구독자 데이터를 예시로 할당하는 것과 쿠폰 등급을 선언, 초기화 하는 과정을 빠르게 정리하겠다.

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/c91fd50f-daf8-47fe-8d26-cb9d70287b15)
(DB에서 조회된 데이터를 JS의 객체로 표현한 사진)

```JS
---
    var subscriber = {
        email: "sam@pmail.com",
        rec_count: 16,
    };
---
```

```java
---
    // Subscriber 객체 정의
    public class Subscriber {
        private String email;
        private int rec_count;

        // Getter, Setter 메소드
        public String getEmail() {
            return this.email;
        }
        public void setEmail(String email) {
            this.email = email;
        }
        
        public int getRec_count() {
            return this.rec_count;
        }
        public void setRec_count(int rec_count) {
            this.rec_count = rec_count;
        }
    }

    ...

    public void testMethod() {
        // 쿠폰 등급
        String rank1 = "best";
        String rank2 = "good";


        // 객체 선언, 기본 생성자 메소드를 통한 초기화, 참조형(Reference type) 변수의 초기화
        Subscriber subscriber = new Subscriber();

        subscriber.setEmail("sam@pmail.com");
        subscriber.setRec_count(16);
    }
---
```


자, 이제 함수(Method)를 통해 구독자의 등급을 나누는 서비스 로직을 구현할 것이다.
기준은 이렇게 되었다.

1. 추천 수 10개 이상은 best
2. 이외의 모든 유저에게는 good

책에서는 이를 분기처리를 통해 등급을 구분하고 있었다.

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/2672552e-c455-4d93-b4f2-eb8c69c60b2f)

```JS
---
    function subCouponRank(subscriber) {
        if(subscriber.rec_count >= 10)
            return "best";
        else
            return "good";
    }
---
```

```java
---
    public String subCouponRank(Subscriber subscriber) {
        if(subscriber.getRec_count >= 10) 
            return "best";
        else
            return "good";
    }

---
```

이렇게 만들어진 위의 등급을 나누는 method는 언제든지 재사용 가능하고 명확하며 구분하기 쉽다.
그리고 위의 method는 같은 값을 넣으면 항상 같은 결과를 도출해낼 것이다.
즉, 이렇게 만들어진 기능은 계산의 특징을 띄게된다.

책에서 설명하는 계산 로직을 몇 개 더 나열하겠다.

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/0193c604-8812-4876-add3-a62c9f0875a8)
(쿠폰 데이터 조회하기)

위의 쿠폰 데이터를 등급별로 정리할 예정이다.
JS 코드의 원본을 먼저 보자

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/2ec2fdcb-10c2-4549-8051-099598574bcd)

```JS
---
    function selectCouponsByRank(coupons, rank) {
        var ret = [];
        for(var c = 0; c < coupons.length; c++) {
            var coupon = coupons[c];
            // === 는 양측 데이터의 타입까지 비교한다.
            if(coupon.rank === rank)
                ret.push(coupon.code);
        }

        return ret;
    }
---
```

```Java
---
    // DB에서 조회해오는 쿠폰 데이터를 담을 객체
    public class Coupon {
        private String code;
        private String rank;

        // Getter, Setter 생략
    }

    ...


    public List<String> selectCouponsByRank(List<Coupons> coupons, String rank) {
        // return을 담을 List<String>
        List<String> ret = new ArrayList<Coupon>();

        // 파라미터로 받은 List의 크기 만큼 동작
        for(int c = 0; c < coupons.size(); c++) {
            Coupon coupon = coupons.get(c);

            // === -> .equals()
            if(coupon.getRank().equals(rank))
                ret.add(coupon.getCode());
        }

        return ret;
    }
---
```

위의 method는 이제 기준 랭크를 파라미터로 받는다면 List에 담긴 Coupon 객체의 rank 속성과 비교해서 등급 별 리스트를 줄것이다.
이는 같은 리스트, 같은 기준의 rank를 주면 항상 같은 결과값을 주는 계산의 역할을 한다.

---

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/923c0314-8731-4f48-9d49-69336d86ed6b)
위의 사진은 상단의 구독자의 등급을 매기는 계산과 이 사진 바로 상단의 쿠폰을 나누는 계산으로 만들어질 또 하나의 계산이다.
(유저의 등급과 쿠폰이면 보낼 이메일을 만들 수 있다는 의미의 계산이다.)
(계속하여 계산만 예시로 보여줘서 스킵하겠다.)

![image](https://github.com/cotes2020/jekyll-theme-chirpy/assets/77370682/007c68f0-b32c-4e3e-80ca-16f8efccab27)
위의 사진은 여러 계산을 통해 구독자들에게 보낼 이메일을 만드는 로직이다.
바로 위의 emailForSubscriber method를 구독자 수 만큼 반복하여 만들어진 이메일의 List 를 return 한다.

---

※※ 이메일 보내기는 액션입니다.
