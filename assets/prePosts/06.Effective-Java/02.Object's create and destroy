# 2장, 객체 생성과 파괴

### 아이템 목록
1. 생성자 대신 정적 팩터리 메서드를 고려하라
2. 생성자에 매개변수가 많다면 빌더를 고려하라
3. private 생성자나 열거 타입으로 싱글턴임을 보증하라
4. 인스턴스화를 막으려거든 private 생성자를 사용하라
5. 

---

## ● 아이템 1: 생성자 대신 정적 팩터리 메서드를 고려하라

<b>정적 팩터리 메서드 (static factory method)</b>

우선 키워드를 느낀대로 정리해보자.

정적: static, 메모리 상 거주하게 되는 객체
팩터리: 객체를 생성하는 역할을 의미하는 키워드

아이템 1의 제목과 연관지어 해석하면,
생성자 메서드 대신에 정적으로 객체의 인스턴스를 획득할 수 있는 방식의 메서드의 채택을 고려하라.

<b>장점</b>

첫 번째. 이름을 가질 수 있다.
메서드 명명규칙의 정책을 잘만 설계하면 메서드가 반환하는 객체의 특성을 쉽게 묘사할 수 있다.
하지만 일반 개발자가 이렇게 짜여진 레거시 코드를 활용해 프로그래밍 한다면 익숙해 지기 전까지
클래스 하나하나를 뜯어서 팩터리 역할을 하는 메서드를 찾아내야하는 번거로움이 생길 수 있다.
그래서 책에서도 설명하지만 관용적으로 사용되는 getInstance(), INSTANCE 등을 예시로 사용하는 모습을 볼 수 있다.

두 번째. 호출될 때마다 인스턴스를 새로 생성하지는 않아도 된다.
불변 클래스 (immutable class, 상태 값을 임의로 수정하지 않게 설계한 클래스) 를 활용하거나 캐싱을 이용할 때 불필요한 인스턴스 획득을 막을 수 있다고 한다.
그래서 생성 비용이 큰 객체가 자주 요청되는 상황에 성능을 크게 끌어올릴 수 있다고 한다.

세 번째, 반환 타입의 하위 타입 객체를 반환할 수 있는 능력이 있다.
반환 값으로 구현 클래스를 공개하지 않고도 반환할 수 있어서 API를 작게 유지할 수 있다.
그리고 이 기술은 인터페이스를 정적 팩터리 메서드의 반환 타입으로 사용하는 인터페이스 기반 프레임워크(아이템 20) 를 구현하는 핵심 기술이 된다고 한다.

네 번째, 입력 매개변수에 따라 매번 다른 클래스의 객체를 반환할 수 있다.
책에서는 이를 활용한 클래스인 EnumSet 을 예시로 든다.
코드를 확인해보자.

```java
public class EnumSetMainClass {

    public enum Week { MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY; }
    
    public enum AllCase {
        A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,
        QW,WE,ER,RT,TY,YU,UI,IO,OP,PA,AS,SD,DF,FG,GH,HJ,JK,KL,LZ,ZX,XC,CV,VB,BN,NM,
        QWE,WER,ERT,RTY,TYU,YUI,UIO,IOP,OPA,PAS,SDF,DFG,FGH,GHJ,HJK,JKL,KLZ,LZX,ZXC,XCV,CVB,VBN,BNM;
    }
    
    public static void main(String... args) {
        EnumSet<Week> weekEnumSet = EnumSet.allOf(Week.class);
        System.out.println("allCaseEnumSet.count: " + Week.values().length);
        System.out.println("allCaseEnumSet.class: " + allCaseEnumSet.getClass());

        EnumSet<AllCase> allCaseEnumSet = EnumSet.allOf(AllCase.class);
        System.out.println("allCaseEnumSet.count: " + AllCase.values().length);
        System.out.println("allCaseEnumSet.class: " + allCaseEnumSet.getClass());
    }
}
```

> 출력
> 
> weekEnumSet.count: 7
> weekEnumSet.class: class java.util.RegularEnumSet
> allCaseEnumSet.count: 74
> allCaseEnumSet.class: class java.util.JumboEnumSet

열거형 데이터의 개수와 그 열거형 데이터를 저장할 EnumSet 의 구현 클래스를 출력한 코드이다.
확인하면 7개의 개수를 가지는 EnumSet은 RegualEnumSet 이 구현됐고, 74개의 개수를 가진 EnumSet은 JumboEnumSet 이 구현됐다.
이는 EnumSet 의 구현부분 코드를 확인하면 더 명확한데,

```java
// 클라이언트가 호출한 allOf() 메서드
// 확인하면 noneOf 메서드를 호출하는 것을 확인할 수 있는데,
public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType) {
    EnumSet<E> result = noneOf(elementType);
    result.addAll();
    return result;
}

// noneOf 케서드에서는 매개변수로 전달된 elementType 에 들어있는 열거형 데이터의 집합을 제네릭 와일드 카드를 이용해서 배열로 담아둔다.
// 그리고 담아둔 데이터의 개수에 따라 RegualEnumSet, JumboEnumSet 을 상황에 맞춰 반환한다.
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType) {
    Enum<?>[] universe = getUniverse(elementType);
    if (universe == null)
        throw new ClassCastException(elementType + " not an enum");

    if (universe.length <= 64)
        return new RegularEnumSet<>(elementType, universe);
    else
        return new JumboEnumSet<>(elementType, universe);
}
```

위처럼 상황에 맞춰 구현할 클래스를 직접 선택하여 반환하게 하는 것이 우리가 네 번째 장점으로 뽑은 것이다.

다섯 번째 장점도 위에 설명한 바와 크게 다르지 않으니 우선 생략하고 <b>단점</b>을 보겠다.

---

<b>단점</b>

첫 번째, 상속을 하려면 public이나 protected 생성자가 필요하니 정적 팩터리 메서드만 제공하면 하위 클래스를 만들 수 없다.
정적 팩터리 메서드는 기존의 기본 생성자 등을 private 으로 묶어 구현하는 형태로 될 것이다.
그렇게 될 경우, 본인을 상속한 자식 클래스에서 생성자에 의해 super(); 가 호출될 수 없게된다.
즉, 상속을 할 수가 없다.
하지만 이 제약은 상속(is-a) 보다 컴포지션(has-a)을 사용하도록 유도하며, 불변 타입으로 만들 수 있어서 오히려 장점으로 받아들여 진다.

두 번째, 정적 팩터리 메서드는 프로그래머가 찾기 어렵다.
이 단점은 내가 첫 번째 장점에 정리해뒀으니 패스 하겠다.

> 아이템 1 에서 획득한 키워드
> 
> 1. BigInteger, BigDecimal
> java.math 패키지의 하위 클래스이다.
> 크기가 큰 정수를 다루기 위한 class 로, 특히 부동소수점에 의해 정확한 계산이 필요한 정수타입의 경우, BigDecimal 을 사용할 것을 추천한다.
> 
> 2. 플라이웨이트 패턴 (FlyWeight pattern), 브리지 패턴 (Bridge pattern)
> 플라이웨이트 패턴: 캐싱의 일종으로 구조적 디자인 패턴 중 하나이다.
> 같은 속성의 값으로 같은 인스턴스를 획득하려 하면, 임의로 지정한 저장소에서 해당 속성의 값을 가지는 인스턴스가 저장되어 있는지 확인한다.
> 만약 인스턴스가 존재하면 해당 인스턴스의 참조값(주소) 를 반환하고, 없을 경우 인스턴스를 새로 획득하여 저장소에 저장해두고 후에 조회될 경우 반환한다.
> 브리지 패턴: 관계가 없는 인터페이스 들을 연결하는 패턴이다.
> 두 인터페이스를 구현해야 하는 상황이라면 하나의 인터페이스는 implements 하여 구현을 강제한다. (정적 메소드로 선언한 것 제외)
> 그리고 오버라이딩 된 메소드에서 다른 인터페이스의 메소드를 호출한다.
> 이렇게 연관이 없던 두 인터페이스 간의 연결이 구현으로 인해서 이루어지는 패턴이다.

--- 

## ● 아이템 2: 생성자에 매개변수가 많다면 빌더를 고려하라

정적 팩터리 메서드의 단점을 먼저 이야기 한다.
초기화에 필요한 매개변수가 많아지는 생성자의 경우 대응하기 어려워 진다는 것이다.

그에따라 몇 해결 방법을 제안하는데, 빌더 패턴이 등장하기 전까지는 모두 그냥저냥한 패턴이다.

패턴 1. 점층적 생성자 패턴 (Telescoping Constructor Pattern)

매개변수가 필요한 상황, 책에서는 멤버 변수로 선언된 모든 상황을 설명하려 하는 것 같다.
그렇게 될 경우 생성자 메서드가 오버로드 되어 생성될 개수는 멤버 변수로 만들 수 있는 집합의 경우의 수에 해당한다.

정말 너무 많은 수가 등장 할 수 있다.
그리고 이렇게 선언된 생성자 메서드의 경우 순서에 따라 데이터의 역할이 굉장히 큰 변수를 만들 수 있다.
이는 일반 개발자가 소스 코드를 확실하게 파악해야 하며 개발에도, 유지보수에도 어려움을 겪을 가능성이 크다.

즉, 가동성이 땅을 친다.


패턴 2. 자바빈즈 패턴 (JavaBeans Pattern)

쉽게 생각하면 인스턴스를 획득한 후, 수정자 메서드 (setter) 를 통해 필요한 모든 값을 바인드 해주는 패턴이다.
내가 근무할 때 많이 사용했던 패턴이기도 하고 제일 무난하다고 생각했다.
하지만 책에서 설명하는 단점이 여럿 있다.

1. 우선 객체 하나를 위해 수 많은 메서드를 호출해야 한다.
2. 객체가 완전히 생성되기 전까지는 일관성 (consistency) 이 무너진 상태에 놓인다.
    ㄴ 계속해서 객체가 바뀌어야 하기 때문.
3. 클래스를 불변으로 만들 수 없다.
    ㄴ 불변이라고? 그러면 단점 2번이 성립할 수 없고, 애초에 자바빈즈 패턴이 성립하지 못 한다.

이러한 자바빈즈 패턴의 문제점을 위해 생성이 끝난 객체를 수동으로 얼리고 (freezing) 얼리기 전에는 사용할 수 없게 하는 방법도 있다고 한다.
이 방법은 이번 아이템에서 내가 찾아내지 못한 방법이다.
내가 발표자가 아니라면 꼭 질문에 넣을 것이다. ^^

패턴 3. 빌더 패턴 (Builder Pattern)

드디어 책에서 설명하고 하는 패턴이다.
위 패턴을 보고 여태 롬복에서 제공하는 @Builder  애노테이션이 같은 역할을 한다고 믿었다.
하지만 @Builder 애노테이션으로 생성되는 소스를 디컴파일러를 통해 확인하니 빌더패턴과 다르게 단순히 모든 멤버 변수를 매개 변수로 받는 생성자 메서드를 추가하는 것이었다.

음... 하지만 디컴파일을 통해 생성된 코드와 다르게 몇 메서드가 추가된 것을 보면 내가 삽질을 덜 한 것일 것 같다.
우선 빌드 패턴의 소스를 보자.

```java
public class BuilderPatternClass1 {
    // 필수
    private final int a;
    private final int b;
    // 선택
    private final int c;
    private final int d;
    private final int e;
    
    private BuilderPatternClass1(Builder builder) {
        this.a = builder.a;
        this.b = builder.b;
        this.c = builder.c;
        this.d = builder.d;
        this.e = builder.e;
    }
    
    public static class Builder {
        // 필수
        private final int a;
        private final int b;
        
        // 선택
        private int c;
        private int d;
        private int e;
        
        public Builder(int a, int b) {
            this.a = a;
            this.b = b;
        }
        
        public Builder c(int c) {
            this.c = c;
            return this;
        }
        
        public Builder d(int d) {
            this.d = d;
            return this;
        }
                
        public Builder e(int e) {
            this.e = e;
            return this;
        }
        
        public BuilderPatternClass1 build() {
            return new BuilderPatternClass1(this);
        }
    }
}

...

public class MainClass {

    public static void main(String... args) {
        
        BuilderPatternClass1 builderPatternClass1 = new BuilderPatternClass1
                .Builder(12, 8)
                .c(100)
                .d(200)
                .e(300)
                .build();
    }

}
```

우선 특징 몇 가지를 살펴보자.

1. Builder 를 매개변수로 하는 생성자 메서드가 private 으로 선언되어 있다는 점
2. 정적 중첩 클래스로 Builder 로 정의되어 있다는 점
3. 모든 멤버 변수가 final 로 선언되어 함부로 변경할 수 없는 객체가 되었다는 점
4. Builder 클래스 내에 build 메서드가 상위 클래스의 생성자 메서드를 호출한다는 점 (의존성이 강하다.)

우선 3번 특징에 의하여 한 번 만들어진 BuilderPatternClass1 클래스의 인스턴스는 불변이다.
그리고 한 번 인스턴스를 생성할 때 메서드를 이어지듯 연결하여 사용할 수 있는데, 이를 플루언트 API (Fluent API), 혹은 메서드 연쇄 (Method Chaining) 이라고 한다.
그리고 1번, 2번, 4번의 특징이 섞인 것이 내가 예시로 놓은 MainClass 클래스의 main 메서드에서 새로 인스턴스를 얻는 과정의 그것이다.
직접 new 예약자에 의해 호출되는 것은 정적 중첩 클래스 내부의 Builder 메서드 이다.
그 후 1번의 특징처럼 private 으로 선언된 멤버 변수를 메서드를 통해 수정하는 모습을 보인다.
그리고 build 메서드를 통해 private 으로 정의되고 Builder 를 매개변수로 받는 BuilderPatternClass1 클래스의 생성자 메서드를 호출한다.
이로서 우리는 인스턴스를 얻을 수 있다.

자바의 빌더 패턴은 파이썬과 자바스크립트의 선택적 매개변수를 따라한 것이라고 한다.
하단의 자바스크립트의 선택적 매개변수의 예시 코드이다.

```javascript
function choosableParameter(a, b = {}, c = null) {
    ...
}
```

아이템 2의 마지막 부분에 재귀적 타입 한정을 이용하는 클래스를 구현했는데, 이는 정리할 시간이 조금 부족할 것 같아 생략한다.

> 아이템 2에서 획득한 키워드
> 
> 공변반환 타이핑 (covariant return typing)
> 하위 클래스의 메서드가 상위 클래스의 메서드가 정의한 반환 타입이 아닌 그 하위 타입을 반환하는 기능.

---

## ● 아이템 3: private 생성자나 열거 타입으로 싱글턴임을 보증하라,
● 아이템 4: 인스턴스화를 막으려거든 private 생성자를 사용하라

4번 아이템은 내용이 많지 않기도 하고, 싱글턴에도 적용할 수 있어 합쳤다.

우선 자바빈으로 등록하지 않고 싱글턴을 만들 수 있는 방법을 몇 가지 나열하겠다.

public static final 필드 방식의 싱글턴

```java
public class FirstSingletonClass {
    
    public static final FirstSingletonClass INSTANCE = new FirstSingletonClass();
    private FirstSingletonClass() {
        System.out.println("이거 실행되면 안되는데 FirstSingletonClass");
    }

}
```

우선 기본 생성자 메서드를 private 으로 정의한 상태이다.
그리고 인스턴스는 static final 예약자를 통하여 싱글턴임을 보장하는 방식이다.

하지만 이 방법은 리플렉션 API인 AccessibleObject.setAccessible 을 사용해 private 생성자가 호출될 수 있다.

적용 예시

```java

public class FirstSingletonMainClass {
    
    public static void main(String... args) {
        FirstSingletonClass firstSingletonClass = FirstSingletonClass.INSTANCE;
        firstSingletonClass.setString("무야호~");
        firstSingletonClass = FirstSingletonClass.INSTANCE;
        System.out.println("그만큼 신나신 거지~ " + firstSingletonClass.getString());

        // private 생성자를 reflect 를 통해 접근하기
        FirstSingletonClass isNotAgreedInstance = null;
        
        try {
            // 클래스를 제네릭 와일드카드를 통해 가져오기
            Class<?> targetClass = FirstSingletonClass.class;
            
            // 파라미터가 없고 private 으로 선언된 기본 생성자를 가져오기(NoSuchMethodException 발생 가능(메소드가 없는 경우 예외 던짐))
            Constructor<?> privateConstructor = targetClass.getDeclaredConstructor();
            
            // setAccessible 메서드를 통해 private 등의 접근 제한자로 막힌 메소드의 접근을 허용 - 이 부분이 책에서 설명한 내용
            privateConstructor.setAccessible(true);
            
            // newInstance() 메서드를 통해 Object 를 반환할 때, 명시적 박싱을 통해 원하는 클래스로 형변환
            // InvocationTargetException: invoke 시에 메서드에서 발생한 exception 이 마치 invoke 구문에서 발생한 것처럼 보이기 때문에 InvocationTargetException 자체의 stack trace 만으로 에러를 해결하기 어렵다.
                // 그래서 Wrapping 한 예외 클래스이다.
            // InstantiationException: newInstance() 메서드를 통해 인스턴스 생성 시에, 지정된 객체의 인스턴스를 생성할 수 없는 경우에 throw
            // IllegalAccessException: 허가되지 않은 객체, 메서드, 필드 등에 접근하려 할 경우 발생
            isNotAgreedInstance = (FirstSingletonClass) privateConstructor.newInstance();
            
            // 접근성을 되돌려 코드 무결성을 유지
            privateConstructor.setAccessible(false);
        } catch (NoSuchMethodException noSuchMethodException) {
            // 이건 사실 추천하지 않는 방법이다.
            // 로그에 정확한 예외 발생 위치가 노출되기 때문에 보안에 위협이 될 수 있다.
            noSuchMethodException.printStackTrace();
        } catch (InvocationTargetException invocationTargetException) {
            invocationTargetException.printStackTrace();
        } catch (InstantiationException instantiationException) {
            instantiationException.printStackTrace();
        } catch (IllegalAccessException illegalAccessException) {
            illegalAccessException.printStackTrace();
        }

        System.out.println("firstSingletonClass: " + System.identityHashCode(firstSingletonClass));
        System.out.println("isNotAgreedInstance: " + System.identityHashCode(isNotAgreedInstance));
        System.out.println("firstSingletonClass.getString: " + firstSingletonClass.getString());
        System.out.println("isNotAgreedInstance.getString: " + isNotAgreedInstance.getString());
    }
}

```

> 이거 실행되면 안되는데 FirstSingletonClass
> 그만큼 신나신 거지~ 무야호~
> 이거 실행되면 안되는데 FirstSingletonClass
> firstSingletonClass: 209813603
> isNotAgreedInstance: 312116338
> firstSingletonClass.getString: 무야호~
> isNotAgreedInstance.getString: null


그리고 두 번째 방식은 INSTANCE 를 private 으로 선언하고 해당 객체를 호출하는 메서드를 추가한다.
하지만 해당 방법도 리플렉션에 안전하지 않은 상태이다.

쓰레드에 안전하며 가장 효율적인 방법은 enum 을 활용하는 것이라고 한다.

---

그리고 아이템 4에서 정말 물어보고 싶은 개념이 나왔다.

java.util.Collections 처럼 특정 인터페이스를 구현하는 객체를 생성해주는 정적 메서드 (혹은 팩터리) 를 모아놓을 수도 있다..

이게 뭐야
동료랑 상의해도 정확한 설명을 모르겠다.
뭘까...

## ● 아이템 5: 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

만약 특정 클래스에 의존하는 멤버 변수가 있다고 해보자.
특히 책에서는 이를 문자열 확인을 위해 바탕이 되는 데이터를 멤버 변수로 선언하여 예시를 든다.

이러한 객체는 직접 구현, 호출할 수도 있지만 여러 곳에서 각 객체 별로 구현되는 경우도 있고, 직접적으로 사용되지 않는 경우도 있기에 초기화를 하는 방식에 다른 방식을 지원하고자 한다.
바로 정적 유틸리티 클래스나 싱글턴 방식으로 구현하는 것.

하지만 이렇게 사용하는 자원에 따라 동작이 달라지는 클래스에는 정적 유틸리티 클래스나 싱글턴 방식이 적합하지 않다.
이 보다는 인스턴스를 획득할 때 생성자에 필요한 자원을 넘겨주는 방식이 낫다.

